<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>IPTV</title>
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

<style>
  :root{
    --bg:#101217;
    --panel:#161c21;
    --muted:#9ba7b2;
    --accent:#00c86b;
    --text-size:16px;
  }
  /* Adaptive font: base smaller for mobile, +10% for wide screens >=1200px */
  html,body{height:100%;margin:0;background:var(--bg);color:#e9eef1;font-family:system-ui,Roboto,Arial,sans-serif;font-size:var(--text-size)}
  @media (min-width:1200px){
    :root{--text-size:17.6px} /* +10% */
  }

  *{box-sizing:border-box}
  .app{display:grid;grid-template-columns:360px 1fr;gap:12px;height:100vh;padding:12px}

  /* LEFT list */
  .left{background:var(--panel);border-radius:10px;padding:12px;overflow:hidden;display:flex;flex-direction:column}
  .header{display:flex;align-items:center;gap:10px;margin-bottom:8px}
  .title{font-weight:600;font-size:1.05rem;color:#fff}
  .search{margin-top:6px}
  .search input{
    width:100%;padding:9px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);
    background:#0b0f12;color:var(--muted);outline:none;font-size:0.98rem;
  }

  .list{margin-top:10px;overflow:auto;flex:1;padding-right:6px}
  /* MODIFICADO: Añadido flexbox para alinear el logo y el texto */
  .chan{
    padding:10px 12px;border-radius:8px;margin-bottom:8px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    cursor:pointer;background:transparent;border:1px solid transparent;transition:background .12s,transform .08s;
  }
  .chan:hover{background:rgba(255,255,255,0.02);transform:translateX(4px)}
  .chan.sel{background:linear-gradient(90deg, rgba(0,200,120,0.07), rgba(0,200,120,0.03));border:1px solid rgba(0,200,120,0.14)}
  
  /* AÑADIDO: Contenedor para el logo y el nombre */
  .chan-info {
    display: flex;
    align-items: center;
    gap: 10px; /* Espacio entre el logo y el nombre */
    overflow: hidden;
    flex-grow: 1;
    min-width: 0;
  }

  /* AÑADIDO: Estilo del Logo */
  .logo {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    overflow: hidden;
    background: rgba(255,255,255,0.05); /* Fondo para iniciales/carga */
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    color: var(--muted);
    font-weight: 600;
    flex-shrink: 0; /* Evita que se encoja */
  }
  .logo img {
    width: 100%;
    height: 100%;
    object-fit: contain; /* Ajuste para logos */
    background: #fff; /* Fondo blanco si el logo es PNG transparente */
  }

  .cname{
    overflow:hidden;white-space:nowrap;text-overflow:ellipsis;
    max-width:200px; /* Reducido para hacer espacio para el logo */
    font-size:0.98rem;
  }
  .playbtn{font-size:0.92rem;padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);color:var(--muted);background:transparent}

  /* RIGHT player */
  .right{background:var(--panel);border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:10px}
  .now{display:flex;align-items:center;gap:12px}
  .now .t{font-weight:600;font-size:1.05rem;color:#fff; text-align:left; width:100%}
  .videoWrap{flex:1;position:relative;background:#000;border-radius:10px;overflow:hidden;display:flex;align-items:center;justify-content:center}
  video{width:100%;height:100%;background:#000;outline:none;border-radius:6px}
  .overlay{position:absolute;left:12px;right:12px;top:12px;padding:10px;border-radius:8px;background:rgba(0,0,0,0.68);color:#ffb3b3;font-size:0.98rem;display:none;z-index:5}
  .spinner{position:absolute;right:12px;top:12px;padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.04);color:var(--muted);font-size:0.95rem;display:none}

  /* responsive: stack on small screens */
  @media (max-width:900px){
    .app{grid-template-columns:1fr;grid-auto-rows:auto;height:100vh;padding:10px}
    .left{order:2; height:40vh}
    .right{order:1; height:auto}
    .cname{max-width:60%}
  }
</style>
</head>
<body>
<div class="app" role="application" aria-label="IPTV player">
  <div class="left" aria-hidden="false">
    <div class="header">
      <div class="title">IPTV — Lista</div>
    </div>

    <div class="search">
      <input id="searchInput" placeholder="Buscar canal..." aria-label="Buscar canal" />
    </div>

    <div class="list" id="channelList" role="listbox" aria-label="Lista de canales"></div>
  </div>

  <div class="right">
    <div class="now">
      <div class="t" id="nowTitle">Selecciona un canal</div>
    </div>

    <div class="videoWrap" aria-live="polite">
      <div id="overlay" class="overlay" role="alert" aria-hidden="true"></div>
      <div id="spinner" class="spinner" aria-hidden="true">Cargando…</div>
      <video id="player" controls playsinline crossorigin="anonymous" aria-label="Reproductor"></video>
    </div>
  </div>
</div>

<script>
(async function(){
  const M3U = "https://iptv-org.github.io/iptv/index.m3u";
  const channelListEl = document.getElementById("channelList");
  const searchInput = document.getElementById("searchInput");
  const playerEl = document.getElementById("player");
  const nowTitle = document.getElementById("nowTitle");
  const overlay = document.getElementById("overlay");
  const spinner = document.getElementById("spinner");

  let hls = null;
  const channelEls = [];
  let channels = [];

  // safe fetch text with timeout
  async function fetchText(url, timeout = 15000){
    const controller = new AbortController();
    const tid = setTimeout(()=>controller.abort(), timeout);
    try{
      const res = await fetch(url, {signal: controller.signal});
      clearTimeout(tid);
      return await res.text();
    }catch(e){
      clearTimeout(tid);
      throw e;
    }
  }

  // MODIFICADO: parse M3U ahora extrae tvg-logo
  function parseM3u(text){
    const lines = text.split(/\r?\n/);
    const out = [];
    for(let i=0;i<lines.length;i++){
      const L = lines[i].trim();
      if(!L) continue;
      if(L.startsWith("#EXTINF")){
        const infoLine = L;
        const name = infoLine.includes(",") ? infoLine.substring(infoLine.indexOf(",")+1).trim() : "";
        
        // AÑADIDO: Extracción de tvg-logo usando regex
        let tvgLogo = null;
        const logoMatch = infoLine.match(/tvg-logo="([^"]+)"/);
        if (logoMatch) {
            tvgLogo = logoMatch[1];
        }
        
        // next non-empty line is url
        let j = i+1;
        while(j < lines.length && lines[j].trim()==="") j++;
        const url = (lines[j] || "").trim();
        i = j;
        
        // MODIFICADO: Incluir tvgLogo en el objeto del canal
        out.push({ name: name || url, url, tvgLogo });
      }
    }
    return out;
  }

  // MODIFICADO: create channel element para incluir el icono
  function createChannelEl(item){
    const el = document.createElement("div");
    el.className = "chan";
    el.tabIndex = 0;
    
    // AÑADIDO: Contenedor para el logo y el nombre
    const infoContainer = document.createElement("div");
    infoContainer.className = "chan-info";

    // AÑADIDO: Creación del logo/icono
    const logoWrap = document.createElement("div");
    logoWrap.className = "logo";
    
    if (item.tvgLogo) {
        const img = document.createElement("img");
        img.src = item.tvgLogo;
        img.alt = item.name + " logo";
        img.loading = "lazy";
        
        // Fallback: si la imagen no carga, muestra las iniciales
        img.onerror = () => {
            img.remove();
            logoWrap.textContent = item.name.slice(0, 2).toUpperCase();
        };
        logoWrap.appendChild(img);
    } else {
        // Si no hay logo, muestra las iniciales
        logoWrap.textContent = item.name.slice(0, 2).toUpperCase();
    }
    
    infoContainer.appendChild(logoWrap); // Añade el logo al contenedor

    const nameDiv = document.createElement("div");
    nameDiv.className = "cname";
    nameDiv.textContent = item.name;

    infoContainer.appendChild(nameDiv); // Añade el nombre al contenedor

    const btn = document.createElement("div");
    btn.className = "playbtn";
    btn.textContent = "▶";

    el.appendChild(infoContainer); // Añade el contenedor de info (logo + nombre)
    el.appendChild(btn); // Añade el botón de play

    el.dataset.url = item.url;
    el._item = item;

    // click => play
    el.addEventListener("click", ()=> selectChannel(el, item, false));
    // keyboard support
    el.addEventListener("keydown", (e)=>{
      if(e.key === "Enter" || e.key === " "){
        e.preventDefault();
        selectChannel(el, item, false);
      }
    });

    return el;
  }

  // load M3U and render
  try{
    const txt = await fetchText(M3U, 20000);
    channels = parseM3u(txt);
  }catch(e){
    // Nota: CORS sigue siendo un problema potencial sin un proxy, ajusté el mensaje.
    channelListEl.innerHTML = "<div style='padding:12px;color:#f66'>Error cargando lista (CORS o red)</div>";
    console.error("Error cargando M3U:", e);
    return;
  }

  for(const ch of channels){
    const el = createChannelEl(ch);
    channelListEl.appendChild(el);
    channelEls.push(el);
  }

  // realtime search (R1)
  searchInput.addEventListener("input", ()=>{
    const q = searchInput.value.trim().toLowerCase();
    for(const el of channelEls){
      const txt = (el._item.name || "").toLowerCase();
      el.style.display = txt.includes(q) ? "flex" : "none";
    }
  });

  // try to select the next channel once if current fails (S1)
  function trySelectNextOnce(currentEl){
    const idx = channelEls.indexOf(currentEl);
    if(idx === -1) return;
    const next = channelEls[idx + 1];
    if(next){
      setTimeout(()=> selectChannel(next, next._item, true), 300);
    }
  }

  // simplified HLS-only selectChannel (A1)
  // autoAttempt = true when this selection comes from the auto-next call to avoid infinite loops
  async function selectChannel(el, item, autoAttempt){
    // UI highlight
    channelEls.forEach(c => c.classList.remove("sel"));
    el.classList.add("sel");
    el.scrollIntoView({block: "center", behavior: "smooth"});

    nowTitle.textContent = item.name;
    overlay.style.display = "none";
    overlay.textContent = "";
    spinner.style.display = "block";

    // cleanup previous
    try{ if(hls){ hls.destroy(); hls = null; } }catch(e){}
    try{ playerEl.pause(); playerEl.removeAttribute("src"); playerEl.load(); }catch(e){}

    const src = item.url;
    if(!src || (!src.startsWith("http://") && !src.startsWith("https://"))){
      spinner.style.display = "none";
      overlay.style.display = "block";
      overlay.textContent = "URL inválida";
      if(!autoAttempt) trySelectNextOnce(el);
      return;
    }

    if(Hls.isSupported()){
      hls = new Hls();
      hls.loadSource(src);
      hls.attachMedia(playerEl);
      hls.on(Hls.Events.MANIFEST_PARSED, function(){
        spinner.style.display = "none";
        playerEl.play().catch(()=>{ /* autoplay may be blocked by browser until user interacts */ });
      });
      hls.on(Hls.Events.ERROR, function(event, data){
        console.warn("HLS error", data);
        spinner.style.display = "none";
        overlay.style.display = "block";
        overlay.textContent = "No se pudo reproducir este canal";
        if(!autoAttempt) trySelectNextOnce(el); // auto next only once
      });
    } else if (playerEl.canPlayType('application/vnd.apple.mpegurl')) {
      // Safari native HLS
      playerEl.src = src;
      playerEl.play().then(()=>{ spinner.style.display = "none"; }).catch(()=>{ spinner.style.display = "none"; overlay.style.display = "block"; overlay.textContent = "No se pudo reproducir este canal"; if(!autoAttempt) trySelectNextOnce(el); });
    } else {
      spinner.style.display = "none";
      overlay.style.display = "block";
      overlay.textContent = "Tu navegador no soporta HLS";
      if(!autoAttempt) trySelectNextOnce(el);
    }
  }

  // keyboard navigation (arrows + enter)
  document.addEventListener("keydown", (e)=>{
    if(!channelEls.length) return;
    let idx = channelEls.findIndex(x => x.classList.contains("sel"));
    if(idx === -1) idx = 0;
    if(e.key === "ArrowDown"){ idx = Math.min(channelEls.length - 1, idx + 1); channelEls[idx].focus(); channelEls[idx].scrollIntoView({block:"center"}); }
    if(e.key === "ArrowUp"){ idx = Math.max(0, idx - 1); channelEls[idx].focus(); channelEls[idx].scrollIntoView({block:"center"}); }
    if(e.key === "Enter" && document.activeElement && document.activeElement.classList.contains('chan')){ document.activeElement.click(); }
  });

  // done
  console.log("Canales cargados:", channelEls.length);
})();
</script>
</body>
</html>
